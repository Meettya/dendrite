// Generated by CoffeeScript 1.3.3

/*
Test suite for node AND browser in one file
So, we are need some data from global
Its so wrong, but its OK for test
*/


(function() {
  var Dendrite, lib_path,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  lib_path = (typeof GLOBAL !== "undefined" && GLOBAL !== null ? GLOBAL.lib_path : void 0) || '';

  Dendrite = require("" + lib_path + "dendrite");

  describe('Dendrite:', function() {
    var async_obj, callback_simple, callback_simple_obj, callback_with_args, callback_with_error, dendrite_obj, huge_logic, result_simple, result_with_args;
    dendrite_obj = result_simple = result_with_args = null;
    callback_simple = function() {
      return result_simple = true;
    };
    callback_simple_obj = {
      topics: 'callback_simple',
      callback: callback_simple,
      watchdog: void 0,
      context: {}
    };
    callback_with_args = function(topic, a, b) {
      return result_with_args = a + b;
    };
    callback_with_error = function() {
      throw new Error('callback stop');
    };
    huge_logic = {
      internal_var: 0,
      test_function: function(topic, a, b) {
        switch (topic) {
          case 'one':
            return this.internal_var += a + b;
          case 'two':
            return this.internal_var += 10 * (a + b);
          case 'three':
            return this.internal_var += 400;
          default:
            return this.internal_var += 44;
        }
      }
    };
    async_obj = {
      internal_var: 0,
      calc_func: function(n) {
        return this.internal_var = n * n;
      },
      run_function: function(topic, cb, arg) {
        var _this = this;
        return setTimeout((function() {
          return cb(_this.calc_func(arg));
        }), 0);
      }
    };
    beforeEach(function() {
      dendrite_obj = new Dendrite;
      /*
          Clean up global vars before each test
      */

      result_simple = false;
      result_with_args = false;
      return huge_logic.internal_var = 0;
    });
    describe('class', function() {
      return it('should may be used as base class', function() {
        var SuperDendrite, super_dendrite_obj;
        SuperDendrite = (function(_super) {

          __extends(SuperDendrite, _super);

          function SuperDendrite() {
            return SuperDendrite.__super__.constructor.apply(this, arguments);
          }

          SuperDendrite.prototype.foo = false;

          SuperDendrite.prototype.makeFoo = function() {
            return this.foo = true;
          };

          return SuperDendrite;

        })(Dendrite);
        super_dendrite_obj = new SuperDendrite({
          verbose: 'debug'
        });
        super_dendrite_obj.makeFoo();
        super_dendrite_obj._observer_verbose_level_.should.be.equal(3);
        return super_dendrite_obj.foo.should.to.be["true"];
      });
    });
    describe('#subscribe()', function() {
      it('should register callback and return handle', function() {
        var handle;
        handle = dendrite_obj.subscribe('callback_simple', callback_simple);
        return handle.should.be.deep.equal(callback_simple_obj);
      });
      it('should keep callback unfired on register', function() {
        dendrite_obj.subscribe('callback_simple', callback_simple);
        return result_simple.should.not.be["true"];
      });
      return it('should skip duplicate topic at register', function() {
        dendrite_obj.subscribe('callback_simple callback_simple', callback_simple);
        return dendrite_obj._subscriptions_['callback_simple'].length.should.be.equal(1);
      });
    });
    describe('#subscribeGuarded()', function() {
      it('should register callback and watchdog and return handle', function() {
        var handle, watchdog;
        callback_simple_obj.watchdog = watchdog = function() {};
        handle = dendrite_obj.subscribeGuarded('callback_simple', callback_simple, watchdog);
        return handle.should.be.deep.equal(callback_simple_obj);
      });
      return it('should fired up watchdog on publishing error', function() {
        var result;
        result = '';
        dendrite_obj = new Dendrite({
          verbose: 'silent'
        });
        dendrite_obj.subscribeGuarded('callback_channel', callback_with_error, function(err, options) {
          return result = err;
        });
        dendrite_obj.publish('callback_channel');
        return result.should.be.match(/Error: callback stop/);
      });
    });
    describe('#publish()', function() {
      it('should return Error on non-string topic args', function() {
        dendrite_obj.subscribe('callback_simple', callback_simple);
        return (function() {
          return dendrite_obj.publish(true);
        }).should.to["throw"](/^Error on call \|publish\| used non-string topics/);
      });
      it('should fired up event with void call', function() {
        dendrite_obj.subscribe('callback_simple', callback_simple);
        dendrite_obj.publish('callback_simple');
        return result_simple.should.be["true"];
      });
      it('should fired up event with args call', function() {
        dendrite_obj.subscribe('callback_with_args', callback_with_args);
        dendrite_obj.publish('callback_with_args', 5, 7);
        return result_with_args.should.be.equal(12);
      });
      it('should fired up some different events on one channel', function() {
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.subscribe('callback_channel', callback_with_args);
        dendrite_obj.publish('callback_channel', 10, 32);
        return result_simple.should.be["true"] && result_with_args.should.be.equal(42);
      });
      it('should not fired up events on different channel call', function() {
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.publish('unknown_callback_channel', 10, 20);
        return result_simple.should.not.be["true"] && result_with_args.should.be.not.equal(30);
      });
      it('should not stop all on some broken events callback', function() {
        dendrite_obj = new Dendrite({
          verbose: 'silent'
        });
        dendrite_obj.subscribe('callback_channel', callback_with_error);
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.publish('callback_channel');
        return result_simple.should.be["true"];
      });
      it('should fired up one subscriber on some different chanel', function() {
        dendrite_obj.subscribe('one two three four', huge_logic.test_function, huge_logic);
        dendrite_obj.publish('one two four', 2, 6);
        return huge_logic.internal_var.should.be.equal(132);
      });
      return it('should work with async function', function(done) {
        var temp_var;
        temp_var = null;
        dendrite_obj.subscribe('async', async_obj.run_function, async_obj);
        dendrite_obj.publish('async', (function() {
          async_obj.internal_var.should.be.equal(4) && temp_var.should.be.equal(0);
          return done();
        }), 2);
        return temp_var = async_obj.internal_var;
      });
    });
    describe('#publishSync()', function() {
      return it('just alias to #publish() and should work in some way', function() {
        dendrite_obj.subscribe('one two three four', huge_logic.test_function, huge_logic);
        dendrite_obj.publish('one two four', 2, 6);
        return huge_logic.internal_var.should.be.equal(132);
      });
    });
    describe('#publishAsync()', function() {
      it('should fired up event with void call', function(done) {
        var void_cb;
        void_cb = function() {
          callback_simple();
          result_simple.should.be["true"];
          return done();
        };
        dendrite_obj.subscribe('callback_simple', void_cb);
        return dendrite_obj.publishAsync('callback_simple');
      });
      it('should fired up event with args call', function(done) {
        var args_cb;
        args_cb = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          callback_with_args.apply(this, args);
          result_with_args.should.be.equal(12);
          return done();
        };
        dendrite_obj.subscribe('callback_with_args', args_cb);
        return dendrite_obj.publishAsync('callback_with_args', 5, 7);
      });
      it('should fired up some different events on one channel', function(done) {
        var args_obj, void_obj, watchdog;
        void_obj = {
          result: false,
          run: function(topic) {
            this.result = true;
            return watchdog.step('void');
          }
        };
        args_obj = {
          result: 0,
          run: function(topic, a, b) {
            this.result = a + b;
            return watchdog.step('args');
          }
        };
        watchdog = {
          counter: 2,
          step: function(name) {
            if ((this.counter -= 1) === 0) {
              void_obj.result.should.be["true"] && args_obj.result.should.be.equal(42);
              return done();
            }
          }
        };
        dendrite_obj.subscribe('callback_channel', args_obj.run, args_obj);
        dendrite_obj.subscribe('callback_channel', void_obj.run, void_obj);
        return dendrite_obj.publishAsync('callback_channel', 10, 32);
      });
      return it('should work truly async', function(done) {
        var args_cb, temp_var;
        temp_var = 0;
        args_cb = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          callback_with_args.apply(this, args);
          (result_with_args.should.be.equal(12)) && (temp_var.should.to.be.equal(10));
          return done();
        };
        dendrite_obj.subscribe('callback_with_args', args_cb);
        dendrite_obj.publishAsync('callback_with_args', 5, 7);
        return temp_var = 10;
      });
    });
    return describe('#unsubscribe()', function() {
      it('should unsubscribe one named function', function() {
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.unsubscribe('callback_channel', callback_simple);
        dendrite_obj.publish('callback_channel');
        return result_simple.should.not.be["true"];
      });
      it('should unsubscribe one named function ONLY and keep others', function() {
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.subscribe('callback_channel', callback_with_args);
        dendrite_obj.unsubscribe('callback_channel', callback_simple);
        dendrite_obj.publish('callback_channel', 22, 43);
        return result_simple.should.not.be["true"] && result_with_args.should.be.equal(65);
      });
      it('may not unsubscribe unnamed (un-referenced) function', function() {
        var tmp;
        tmp = false;
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.subscribe('callback_channel', function() {
          return tmp = true;
        });
        dendrite_obj.unsubscribe('callback_channel', function() {
          return tmp = true;
        });
        dendrite_obj.publish('callback_channel');
        return result_simple.should.be["true"] && tmp.should.be["true"];
      });
      it('should unsubscribe unnamed (un-referenced) function when handle used', function() {
        var handle, tmp;
        tmp = false;
        dendrite_obj.subscribe('callback_channel', callback_simple);
        handle = dendrite_obj.subscribe('callback_channel', function() {
          return tmp = true;
        });
        dendrite_obj.unsubscribe(handle);
        dendrite_obj.publish('callback_channel');
        return result_simple.should.be["true"] && tmp.should.be["false"];
      });
      it('should silent and working on after un-existents function unsubscribe', function() {
        dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj.unsubscribe('callback_channel', callback_with_args);
        dendrite_obj.publish('callback_channel');
        return result_simple.should.be["true"];
      });
      it('should unsubscribe all binded event on some different chanel if callback undefined', function() {
        dendrite_obj.subscribe('one two three four', huge_logic.test_function, huge_logic);
        dendrite_obj.unsubscribe('one two four');
        dendrite_obj.publish('one two three four', 2, 6);
        return huge_logic.internal_var.should.be.equal(400);
      });
      it('should unsubscribe some binded event on some different chanel if callback exists', function() {
        dendrite_obj.subscribe('one two three four', huge_logic.test_function, huge_logic);
        dendrite_obj.unsubscribe('one two three', huge_logic.test_function, huge_logic);
        dendrite_obj.publish('one two three four', 2, 6);
        return huge_logic.internal_var.should.be.equal(44);
      });
      it('should unsubscribe subscriptions ONLY if context matched', function() {
        dendrite_obj.subscribe('one two three four', huge_logic.test_function, huge_logic);
        dendrite_obj.unsubscribe('one two three', huge_logic.test_function, {});
        dendrite_obj.publish('one two', 2, 6);
        return huge_logic.internal_var.should.be.equal(88);
      });
      it('should prevent unsubscribe while publishing ', function() {
        var handle;
        dendrite_obj = new Dendrite({
          verbose: 'error'
        });
        handle = dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj._publishingInc();
        dendrite_obj.unsubscribe(handle);
        dendrite_obj.publish('callback_channel', 'test');
        return result_simple.should.be["true"];
      });
      return it('should resume unsubscribing after publishing ', function() {
        var handle;
        dendrite_obj = new Dendrite({
          verbose: 'error'
        });
        handle = dendrite_obj.subscribe('callback_channel', callback_simple);
        dendrite_obj._publishingInc();
        dendrite_obj.unsubscribe(handle);
        dendrite_obj._publishingDec();
        dendrite_obj.publish('callback_channel', 'test');
        result_simple = false;
        dendrite_obj.publish('callback_channel', 'test');
        return result_simple.should.not.be["true"];
      });
    });
  });

}).call(this);
